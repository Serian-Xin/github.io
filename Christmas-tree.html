<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>åœ£è¯æ ‘ Â· åº•éƒ¨å››åˆ†ä¹‹ä¸€å¯¹é½</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #000420, #0a0a30);
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        .text {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffccdd;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 200, 220, 0.8);
            z-index: 100;
            pointer-events: none;
        }
        .hint {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="text">ğŸ„SZXâ€˜s Merry Christmas! ğŸ„</div>
    <div class="hint">æ»‘åŠ¨æ—‹è½¬ Â· åŒæŒ‡ç¼©æ”¾</div>
    <canvas id="treeCanvas"></canvas>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ç›¸æœºå‚æ•°ï¼ˆé€‚ä¸­è·ç¦»ï¼‰
        let camera = {
            angleX: 0,
            angleY: 0,
            distance: 3.8,
            offsetX: 0,
            offsetY: 0
        };

        let isDragging = false;
        let lastX = 0, lastY = 0;

        let particles = [];
        let snowflakes = [];
        let star = null;
        let groundGlow = [];

        // ğŸ‘‡ æ ‘æ•´ä½“åœ¨ 3D ç©ºé—´ä¸­çš„å‚ç›´åç§»ï¼ˆè´Ÿå€¼è¡¨ç¤ºä¸‹ç§»ï¼‰
        // åŸå§‹æ ‘é«˜çº¦ 2.4ï¼ˆ6å±‚ * 0.4ï¼‰ï¼Œæ˜Ÿæ˜Ÿåœ¨ 2.7
        // æˆ‘ä»¬å¸Œæœ›æ ‘åº•ï¼ˆy=0ï¼‰å‡ºç°åœ¨å±å¹•ä¸‹æ–¹ 1/4 å¤„ â†’ åœ¨ 3D ä¸­ä¸‹ç§»çº¦ -1.0
        const treeYOffset = -1.0;

        // åˆå§‹åŒ–æ›´è‡ªç„¶çš„é”¥å½¢åœ£è¯æ ‘
function initTree() {
    particles = [];
    const layers = 8;                // å¢åŠ å±‚æ•°ï¼Œæ›´ç»†è…»
    const treeHeight = 2.4;          // æ ‘æ€»é«˜ï¼ˆä»åº• y=0 åˆ°é¡¶ y=2.4ï¼‰
    const baseRadius = 1.6;          // åº•éƒ¨æœ€å¤§åŠå¾„

    for (let layer = 0; layer < layers; layer++) {
        // ä»æ ‘é¡¶åˆ°åº•éƒ¨ï¼šlayer=0 æ˜¯é¡¶éƒ¨ï¼Œlayer=layers-1 æ˜¯åº•éƒ¨
        const t = layer / (layers - 1); // 0 ~ 1
        const y = treeHeight * (1 - t); // é¡¶éƒ¨ y=2.4ï¼Œåº•éƒ¨ y=0
        const radius = baseRadius * t;  // é¡¶éƒ¨åŠå¾„â‰ˆ0ï¼Œåº•éƒ¨=baseRadius

        // æ¯å±‚ç²’å­æ•°ï¼ˆé¡¶éƒ¨å°‘ï¼Œåº•éƒ¨å¤šï¼‰
        const count = Math.floor(60 + t * 180);

        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.sqrt(Math.random()) * radius; // å‡åŒ€åˆ†å¸ƒ
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;

            // é¢œè‰²ï¼šç²‰ç´«ç™½äº¤æ›¿
            let color;
            if (Math.random() < 0.4) {
                color = [1, 0.7, 0.9]; // ç²‰
            } else if (Math.random() < 0.7) {
                color = [0.8, 0.7, 1]; // ç´«
            } else {
                color = [1, 1, 1];     // ç™½
            }

            particles.push({ x, y, z, color });
        }
    }

    // æ˜Ÿæ˜Ÿç´§è´´æ ‘é¡¶ï¼ˆåªé«˜å‡ºä¸€ç‚¹ç‚¹ï¼‰
    star = { x: 0, y: treeHeight + 0.15, z: 0, color: [1, 1, 0] };

    // åœ°é¢åå…‰ï¼ˆåœ¨æ ‘åº• y=0 å¤„ï¼‰
    groundGlow = [];
    for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * (baseRadius + 0.4);
        groundGlow.push({
            x: Math.cos(angle) * r,
            y: -0.1, // ç•¥ä½äºæ ‘åº•
            z: Math.sin(angle) * r,
            color: [0.9, 0.85, 1],
            size: Math.random() * 0.7 + 0.2
        });
    }

    // é›ªèŠ±ï¼ˆä¸å˜ï¼‰
    snowflakes = [];
    for (let i = 0; i < 60; i++) {
        snowflakes.push({
            x: (Math.random() - 0.5) * 6,
            y: Math.random() * 5 + 2,
            z: (Math.random() - 0.5) * 6,
            speed: Math.random() * 0.015 + 0.008,
            size: Math.random() * 1.8 + 0.8
        });
    }

    // ğŸ‘‡ å…³é”®ï¼šæ•´ä½“ä¸‹ç§»ï¼Œä½¿æ ‘åº•ï¼ˆy=0ï¼‰ä½äºå±å¹•åº•éƒ¨ 1/4 å¤„
    const treeYOffset = -1.0;
    particles.forEach(p => p.y += treeYOffset);
    star.y += treeYOffset;
    groundGlow.forEach(g => g.y += treeYOffset);
}

        // 3D æŠ•å½±å‡½æ•°ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰
        function project(x, y, z) {
            const cosY = Math.cos(camera.angleY);
            const sinY = Math.sin(camera.angleY);
            const cosX = Math.cos(camera.angleX);
            const sinX = Math.sin(camera.angleX);

            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;

            let y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX;

            x1 += camera.offsetX;
            y1 += camera.offsetY;

            const scale = camera.distance / (camera.distance + z2);
            if (scale <= 0) return null;

            const screenX = x1 * scale * 180 + canvas.width / 2;
            const screenY = -y1 * scale * 180 + canvas.height / 2;

            return { x: screenX, y: screenY, scale };
        }

        // æ¸²æŸ“èƒŒæ™¯æ˜Ÿç‚¹
        function drawStars() {
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 1.2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // æ¸²æŸ“é›ªèŠ±
        function drawSnow() {
            snowflakes.forEach(sf => {
                sf.y -= sf.speed;
                if (sf.y < -1) {
                    sf.y = 5;
                    sf.x = (Math.random() - 0.5) * 6;
                    sf.z = (Math.random() - 0.5) * 6;
                }
                const pos = project(sf.x, sf.y, sf.z);
                if (pos && pos.scale > 0) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, sf.size * pos.scale, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                }
            });
        }

        // æ¸²æŸ“åœ°é¢åå…‰
        function drawGroundGlow() {
            groundGlow.forEach(g => {
                const pos = project(g.x, g.y, g.z);
                if (pos && pos.scale > 0) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, g.size * 12 * pos.scale, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${g.color[0]*255}, ${g.color[1]*255}, ${g.color[2]*255}, ${0.18 * pos.scale})`;
                    ctx.fill();
                }
            });
        }

        // æ¸²æŸ“ç²’å­
        function drawParticles() {
            const time = Date.now() * 0.001;
            particles.forEach(p => {
                const pulse = Math.sin(time * 2 + p.x * 10) * 0.5 + 0.5;
                const alpha = 0.6 + pulse * 0.4;

                const pos = project(p.x, p.y, p.z);
                if (pos && pos.scale > 0) {
                    const size = 1.8 * pos.scale;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${p.color[0]*255}, ${p.color[1]*255}, ${p.color[2]*255})`;
                    ctx.globalAlpha = alpha;
                    ctx.fill();
                }
            });
        }

        // æ¸²æŸ“æ˜Ÿæ˜Ÿ
        function drawStar() {
            if (!star) return;
            const pos = project(star.x, star.y, star.z);
            if (pos && pos.scale > 0) {
                const size = 18 * pos.scale;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a1 = (i * 4) * Math.PI / 5;
                    const a2 = (i * 4 + 2) * Math.PI / 5;
                    const x1 = pos.x + Math.cos(a1) * size;
                    const y1 = pos.y + Math.sin(a1) * size;
                    const x2 = pos.x + Math.cos(a2) * size;
                    const y2 = pos.y + Math.sin(a2) * size;
                    if (i === 0) ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                }
                ctx.closePath();
                ctx.fillStyle = `rgb(${star.color[0]*255}, ${star.color[1]*255}, ${star.color[2]*255})`;
                ctx.fill();

                ctx.shadowColor = 'rgba(255, 255, 0, 0.9)';
                ctx.shadowBlur = 20 * pos.scale;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // ä¸»æ¸²æŸ“å¾ªç¯
        function render() {
            ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawStars();
            drawSnow();
            drawGroundGlow();
            drawParticles();
            drawStar();
        }

        function animate() {
            render();
            requestAnimationFrame(animate);
        }

        // é¼ æ ‡äº¤äº’
        canvas.addEventListener('mousedown', (e) => {
            lastX = e.clientX;
            lastY = e.clientY;
            isDragging = true;
            e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            camera.angleY += deltaX * 0.01;
            camera.angleX += deltaY * 0.01;
            camera.angleX = Math.max(-1.2, Math.min(1.2, camera.angleX));
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.distance -= e.deltaY * 0.002;
            camera.distance = Math.max(2.5, Math.min(5.5, camera.distance));
        });

        // è§¦æ‘¸äº¤äº’
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                lastX = touch.clientX;
                lastY = touch.clientY;
                isDragging = true;
            }
            e.preventDefault();
        });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastX;
                const deltaY = touch.clientY - lastY;
                camera.angleY += deltaX * 0.01;
                camera.angleX += deltaY * 0.01;
                camera.angleX = Math.max(-1.2, Math.min(1.2, camera.angleX));
                lastX = touch.clientX;
                lastY = touch.clientY;
            }
            e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // å¯åŠ¨
        initTree();
        animate();
    </script>
</body>
</html>
