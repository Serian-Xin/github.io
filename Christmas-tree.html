<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Szxçš„åœ£è¯æ ‘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0a2a, #1a1a40);
            font-family: 'Arial', sans-serif;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255,255,255,0.7);
            z-index: 100;
            font-style: italic;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="info">ğŸ„ Merry Christmas! ğŸ„</div>
    <div class="controls">
        <div>å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬è§†è§’</div>
        <div>æ»šè½®ï¼šç¼©æ”¾</div>
        <div>å³é”®æ‹–æ‹½ï¼šå¹³ç§»</div>
    </div>

    <canvas id="treeCanvas"></canvas>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ç›¸æœºæ§åˆ¶
        let camera = {
            angleX: 0,
            angleY: 0,
            distance: 3,
            offsetX: 0,
            offsetY: 0
        };

        let isDragging = false;
        let isRightDragging = false;
        let lastX = 0, lastY = 0;

        // ç²’å­æ•°æ®
        let particles = [];
        let snowflakes = [];
        let star = null;
        let groundGlow = [];

        // åˆå§‹åŒ–é«˜å¯†åº¦åœ£è¯æ ‘ï¼ˆç²‰+è“+ç™½ï¼‰
        function initTree() {
            particles = [];
            const layers = 7; // å¢åŠ å±‚æ•°è®©å½¢çŠ¶æ›´æ˜æ˜¾

            for (let layer = 0; layer < layers; layer++) {
                const radius = 1.3 - layer * 0.16;
                const height = layer * 0.35;
                const count = 200 + layer * 80; // æ›´å¯†é›†ï¼

                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * radius;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const y = height;

                    // ä¸»è¦é¢œè‰²ï¼šç²‰ã€è“ã€ç™½
                    const rand = Math.random();
                    let color;
                    if (rand < 0.4) {
                        // ç²‰è‰²
                        color = [1, 0.6, 0.8];
                    } else if (rand < 0.8) {
                        // è“è‰²
                        color = [0.6, 0.8, 1];
                    } else {
                        // ç™½è‰²ï¼ˆç‚¹ç¼€ï¼‰
                        color = [1, 1, 1];
                    }

                    particles.push({ x, y, z, color });
                }
            }

            // æ›´å¤§çš„æ˜Ÿæ˜Ÿ
            star = { x: 0, y: 2.6, z: 0, color: [1, 1, 0.9] };

            // åœ°é¢å…‰æ™•ï¼ˆæ·¡ç²‰è“ï¼‰
            groundGlow = [];
            for (let i = 0; i < 200; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 2.2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                groundGlow.push({
                    x, y: -0.1, z,
                    color: [0.9, 0.8, 1],
                    size: Math.random() * 1 + 0.3
                });
            }

            // é›ªèŠ±
            snowflakes = [];
            for (let i = 0; i < 70; i++) {
                snowflakes.push({
                    x: (Math.random() - 0.5) * 7,
                    y: Math.random() * 5 + 2,
                    z: (Math.random() - 0.5) * 7,
                    speed: Math.random() * 0.02 + 0.01,
                    size: Math.random() * 2.5 + 1
                });
            }
        }

        // 3D æŠ•å½±å‡½æ•°
        function project(x, y, z) {
            const cosY = Math.cos(camera.angleY);
            const sinY = Math.sin(camera.angleY);
            const cosX = Math.cos(camera.angleX);
            const sinX = Math.sin(camera.angleX);

            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;

            let y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX;

            x1 += camera.offsetX;
            y1 += camera.offsetY;

            const scale = camera.distance / (camera.distance + z2);
            if (scale <= 0) return null;

            const screenX = x1 * scale * 220 + canvas.width / 2;
            const screenY = -y1 * scale * 220 + canvas.height / 2;

            return { x: screenX, y: screenY, scale };
        }

        // æ¸²æŸ“
        function render() {
            ctx.fillStyle = 'rgba(10, 10, 42, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // èƒŒæ™¯æ˜Ÿæ˜Ÿ
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 1.2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // é›ªèŠ±
            snowflakes.forEach(sf => {
                sf.y -= sf.speed;
                if (sf.y < -1) {
                    sf.y = 4;
                    sf.x = (Math.random() - 0.5) * 7;
                    sf.z = (Math.random() - 0.5) * 7;
                }
                const pos = project(sf.x, sf.y, sf.z);
                if (pos && pos.scale > 0) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, sf.size * pos.scale, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.fill();
                }
            });

            // åœ°é¢å…‰æ™•
            groundGlow.forEach(g => {
                const pos = project(g.x, g.y, g.z);
                if (pos && pos.scale > 0) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, g.size * 10 * pos.scale, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${g.color[0]*255}, ${g.color[1]*255}, ${g.color[2]*255}, ${0.25 * pos.scale})`;
                    ctx.fill();
                }
            });

            // åœ£è¯æ ‘ï¼ˆä»åå¾€å‰æ¸²æŸ“ï¼‰
            const sorted = [...particles].sort((a, b) => b.z - a.z);
            sorted.forEach(p => {
                const pos = project(p.x, p.y, p.z);
                if (pos && pos.scale > 0) {
                    const size = 2.8 * pos.scale;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${p.color[0]*255}, ${p.color[1]*255}, ${p.color[2]*255})`;
                    ctx.fill();
                }
            });

            // å¤§æ˜Ÿæ˜Ÿï¼ˆäº”è§’æ˜Ÿï¼‰
            if (star) {
                const pos = project(star.x, star.y, star.z);
                if (pos && pos.scale > 0) {
                    const size = 22 * pos.scale; // æ›´å¤§ï¼
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const a1 = (i * 4) * Math.PI / 5;
                        const a2 = (i * 4 + 2) * Math.PI / 5;
                        const x1 = pos.x + Math.cos(a1) * size;
                        const y1 = pos.y + Math.sin(a1) * size;
                        const x2 = pos.x + Math.cos(a2) * size;
                        const y2 = pos.y + Math.sin(a2) * size;
                        if (i === 0) ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    // æ˜Ÿæ˜Ÿå‘å…‰æ•ˆæœ
                    ctx.fillStyle = `rgb(${star.color[0]*255}, ${star.color[1]*255}, ${star.color[2]*255})`;
                    ctx.fill();

                    // æ·»åŠ å¤–å‘å…‰
                    ctx.shadowColor = 'rgba(255, 255, 200, 0.8)';
                    ctx.shadowBlur = 15 * pos.scale;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        function animate() {
            render();
            requestAnimationFrame(animate);
        }

        // é¼ æ ‡äº¤äº’
        canvas.addEventListener('mousedown', (e) => {
            lastX = e.clientX;
            lastY = e.clientY;
            isDragging = e.button === 0;
            isRightDragging = e.button === 2;
            e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging && !isRightDragging) return;
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            if (isDragging) {
                camera.angleY += deltaX * 0.01;
                camera.angleX += deltaY * 0.01;
                camera.angleX = Math.max(-1.2, Math.min(1.2, camera.angleX));
            }
            if (isRightDragging) {
                camera.offsetX += deltaX * 0.005;
                camera.offsetY -= deltaY * 0.005;
            }
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isRightDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.distance += e.deltaY * 0.01;
            camera.distance = Math.max(1, Math.min(6, camera.distance));
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // å¯åŠ¨
        initTree();
        animate();
    </script>
</body>
</html>
